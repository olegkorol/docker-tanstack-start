import{AsyncLocalStorage as R}from"node:async_hooks";import{H3Event as p,getRequestWebStream as _,getRequestURL as x,eventHandler as b}from"h3";function S(t={}){let e,n=!1;const s=o=>{if(e&&e!==o)throw new Error("Context conflict")};let r;if(t.asyncContext){const o=t.AsyncLocalStorage||globalThis.AsyncLocalStorage;o?r=new o:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const a=()=>{if(r){const o=r.getStore();if(o!==void 0)return o}return e};return{use:()=>{const o=a();if(o===void 0)throw new Error("Context is not available");return o},tryUse:()=>a(),set:(o,l)=>{l||s(o),e=o,n=!0},unset:()=>{e=void 0,n=!1},call:(o,l)=>{s(o),e=o;try{return r?r.run(o,l):l()}finally{n||(e=void 0)}},async callAsync(o,l){e=o;const i=()=>{e=o},c=()=>e===o?i:void 0;g.add(c);try{const f=r?r.run(o,l):l();return n||(e=void 0),await f}finally{g.delete(c)}}}}function T(t={}){const e={};return{get(n,s={}){return e[n]||(e[n]=S({...t,...s})),e[n]}}}const d=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},h="__unctx__",A=d[h]||(d[h]=T()),L=(t,e={})=>A.get(t,e),m="__unctx_async_handlers__",g=d[m]||(d[m]=new Set);function E(t){let e;const n=v(t),s={duplex:"half",method:t.method,headers:t.headers};return t.node.req.body instanceof ArrayBuffer?new Request(n,{...s,body:t.node.req.body}):new Request(n,{...s,get body(){return e||(e=C(t),e)}})}function k(t){return t.web??(t.web={request:E(t),url:v(t)}),t.web.request}function q(){return I()}const w=Symbol("$HTTPEvent");function H(t){return typeof t=="object"&&(t instanceof p||t?.[w]instanceof p||t?.__is_event__===!0)}function P(t){return function(...e){var n;const s=e[0];if(H(s))e[0]=s instanceof p||s.__is_event__?s:s[w];else{if(!((n=globalThis.app.config.server.experimental)!=null&&n.asyncContext))throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");e.unshift(q())}return t(...e)}}const v=P(x),C=P(_);function U(){var t;return L("nitro-app",{asyncContext:!!((t=globalThis.app.config.server.experimental)!=null&&t.asyncContext),AsyncLocalStorage:R})}function I(){const t=U().use().event;if(!t)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");return t}const O=[{path:"/__root",filePath:"/Users/olegkorol/LocalOnly/git-repos/templates/tanstack-react-w-addons-test/src/routes/__root.tsx"},{path:"/api/demo-names",filePath:"/Users/olegkorol/LocalOnly/git-repos/templates/tanstack-react-w-addons-test/src/routes/api.demo-names.ts",$APIRoute:{src:"src/routes/api.demo-names.ts?pick=APIRoute",build:()=>import("../api.demo-names.js"),import:()=>import("../api.demo-names.js")}},{path:"/demo/form",filePath:"/Users/olegkorol/LocalOnly/git-repos/templates/tanstack-react-w-addons-test/src/routes/demo.form.tsx"},{path:"/demo/start/api-request",filePath:"/Users/olegkorol/LocalOnly/git-repos/templates/tanstack-react-w-addons-test/src/routes/demo.start.api-request.tsx"},{path:"/demo/start/server-funcs",filePath:"/Users/olegkorol/LocalOnly/git-repos/templates/tanstack-react-w-addons-test/src/routes/demo.start.server-funcs.tsx"},{path:"/demo/store",filePath:"/Users/olegkorol/LocalOnly/git-repos/templates/tanstack-react-w-addons-test/src/routes/demo.store.tsx"},{path:"/demo/tanstack-query",filePath:"/Users/olegkorol/LocalOnly/git-repos/templates/tanstack-react-w-addons-test/src/routes/demo.tanstack-query.tsx"},{path:"/",filePath:"/Users/olegkorol/LocalOnly/git-repos/templates/tanstack-react-w-addons-test/src/routes/index.tsx"}],$=["GET","POST","PUT","PATCH","DELETE","OPTIONS","HEAD"];function M(t){return b(async e=>{const n=k(e);return await t({request:n})})}const D=t=>e=>({path:t,methods:e});function W(t,e){const n=t.pathname.split("/").filter(Boolean),s=e.sort((r,a)=>{const o=r.routePath.split("/").filter(Boolean);return a.routePath.split("/").filter(Boolean).length-o.length}).filter(r=>{const a=r.routePath.split("/").filter(Boolean);return n.length>=a.length});for(const r of s){const a=r.routePath.split("/").filter(Boolean),o={};let l=!0;for(let i=0;i<a.length;i++){const c=a[i],f=n[i];if(c.startsWith("$"))if(c==="$"){const u=n.slice(i).join("/");if(u!=="")o["*"]=u,o._splat=u;else{l=!1;break}}else{const u=c.slice(1);o[u]=f}else if(c!==f){l=!1;break}}if(l)return{routePath:r.routePath,params:o,payload:r.payload}}}const y=O.filter(t=>t.$APIRoute);function B(t){const e=[];return t.forEach(n=>{const r=n.path.split("/").filter(Boolean).map(a=>a==="*splat"?"$":a.startsWith(":$")&&a.endsWith("?")?a.slice(1,-1):a).join("/");e.push({routePath:`/${r}`,payload:n})}),e}const K=async({request:t})=>{if(!y.length)return new Response("No routes found",{status:404});if(!$.includes(t.method))return new Response("Method not allowed",{status:405});const e=B(y),n=new URL(t.url,"http://localhost:3000"),s=W(n,e);if(!s)return new Response("Not found",{status:404});let r;try{r=await s.payload.$APIRoute.import().then(l=>l.APIRoute)}catch(l){return console.error("Error importing route file:",l),new Response("Internal server error",{status:500})}if(!r)return new Response("Internal server error",{status:500});const a=t.method,o=r.methods[a];return o?await o({request:t,params:s.params}):new Response("Method not allowed",{status:405})};export{D as a,M as c,K as d};
